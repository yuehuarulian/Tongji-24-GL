#include "fluid/renderer/bidirectional_path_tracer.h"

/// \file
/// Implementation of the bidirectional path tracer.

#include <random>

#include "fluid/math/warping.h"
#include "fluid/data_structures/short_vec.h"

namespace fluid::renderer {
	/// A version of \ref _pdf_to_solid_angle() that accepts a normalized direction and the squared distance between
	/// the two points.
	double _pdf_to_solid_angle_norm_diff(
		double pdf_source, vec3d norm_diff, double squared_length, vec3d hit_normal
	) {
		// TODO no handling of infinite light sources here
		// TODO no handling of media here
		pdf_source *= std::abs(vec_ops::dot(hit_normal, norm_diff));
		return pdf_source / squared_length;
	}
	/// Converts the probability density function of a outgoing ray direction into that expressed in solid angles.
	double _pdf_to_solid_angle(double pdf_source, vec3d source, vec3d hit, vec3d hit_normal) {
		vec3d diff = hit - source;
		double sqr_len = diff.squared_length();
		return _pdf_to_solid_angle_norm_diff(pdf_source, diff / std::sqrt(sqr_len), sqr_len, hit_normal);
	}

	/// Stores information about an intersection.
	struct _vertex {
		bsdf surface_bsdf; ///< BSDF of the surface.
		rmat3d tangent; ///< Matrix used to convert directions from world space to tangent space.
		spectrum attenuation; ///< The attenuation of light along the path.
		vec3d
			incoming_ray_dir_tangent, ///< Normalized negative direction of the incoming ray in tangent space.
			position, ///< The position of this vertex.
			geometric_normal; ///< The geometric normal.
		vec2d uv; ///< The UV at this position.
		double
			/// The probability density function of this vertex being generated by the previous vertex, in solid
			/// angles.
			pdf_forward = 0.0,
			/// The probability density function of this vertex being generated by the next vertex, in solid angles.
			pdf_reverse = 0.0;
		const primitive *prim = nullptr; ///< The intersected primitive.
		bool is_delta = false; ///< Indicates whether \ref surface_bsdf is a delta material.

		/// Returns the probability density function of the \ref _vertex \p next being sampled by this \ref _vertex
		/// in solid angles.
		double pdf_from_to(const _vertex &prev, const _vertex &next) const {
			vec3d
				in_norm = (prev.position - position).normalized_unchecked(),
				out_norm = next.position - position;
			double sqr_out_len = out_norm.squared_length();
			out_norm /= std::sqrt(sqr_out_len); // actually normalize out_norm
			double pdf = surface_bsdf.pdf(tangent * in_norm, tangent * out_norm);
			return _pdf_to_solid_angle_norm_diff(pdf, out_norm, sqr_out_len, next.geometric_normal);
		}
		/// Returns the probability density function of the next vertex being sampled by this vertex in solid angles,
		/// if this vertex is a light source.
		double pdf_light_to(const _vertex &next) const {
			vec3d offset = next.position - position;
			double inv_sqr_dist = 1.0 / offset.squared_length();
			offset *= std::sqrt(inv_sqr_dist);
			return
				std::max(warping::pdf_unit_hemisphere_from_unit_square_cosine(tangent * offset), 0.0) *
				inv_sqr_dist *
				std::abs(vec_ops::dot(next.geometric_normal, offset));
		}
	};

	using _path_vec = short_vec<_vertex, 16>; ///< Used to store paths.

	/// Traces a path given the initial ray and the maximum number of bounces.
	///
	/// \param out The output array. It is assumed that this already contains the initial vertex.
	/// \param sc The scene.
	/// \param max_bounces The maximum number of bounces.
	/// \param r The input ray. Its direction is assumed to be normalized.
	/// \param pdf The probability density function of the direction of the initial ray.
	/// \param rnd The random number generator.
	void _trace_path(
		_path_vec &out, const scene &sc, std::size_t max_bounces, ray r, double pdf, transport_mode mode,
		double ray_offset, pcg32 &rnd
	) {
		std::uniform_real_distribution<double> dist(0.0, 1.0);
		double prev_pdf = pdf;
		spectrum attenuation = out.back().attenuation;
		for (std::size_t i = 0; i < max_bounces; ++i) {
			// find intersection
			auto [prim, hit, isect] = sc.ray_cast(r);
			if (!prim) { // no intersection
				break;
			}
			vec3d incoming_direction_tangent = isect.tangent * -r.direction;
			// new vertex
			_vertex &vertex = out.emplace_back();
			vertex.surface_bsdf = isect.surface_bsdf;
			vertex.tangent = isect.tangent;
			vertex.attenuation = attenuation;
			vertex.incoming_ray_dir_tangent = incoming_direction_tangent;
			vertex.position = isect.intersection;
			vertex.geometric_normal = isect.geometric_normal;
			vertex.uv = isect.uv;
			vertex.prim = prim;
			vertex.is_delta = isect.surface_bsdf.is_delta();
			// previous vertex, obtained here since emplace_back() may invalidate references
			_vertex &prev_vert = out[out.size() - 2];
			// sample bsdf for new ray
			bsdfs::outgoing_ray_sample sample = vertex.surface_bsdf.sample_f(
				incoming_direction_tangent, vec2d(dist(rnd), dist(rnd)), mode
			);
			attenuation =
				modulate(attenuation, sample.reflectance) *
				(std::abs(sample.norm_out_direction_tangent.y) / sample.pdf);
			// calculate pdf
			vertex.pdf_forward = _pdf_to_solid_angle(
				prev_pdf, prev_vert.position, vertex.position, isect.geometric_normal
			);
			if (vertex.is_delta) {
				prev_pdf = prev_vert.pdf_reverse = 0.0;
			} else {
				prev_pdf = sample.pdf;
				double reverse_pdf = isect.surface_bsdf.pdf(
					sample.norm_out_direction_tangent, incoming_direction_tangent
				);
				prev_vert.pdf_reverse = _pdf_to_solid_angle(
					reverse_pdf, isect.intersection, prev_vert.position, prev_vert.geometric_normal
				);
			}
			// update
			r = isect.spawn_ray(sample.norm_out_direction_tangent, ray_offset);
		}
	}

	/// Scoped assignment.
	template <typename T> struct _scoped_assignment {
	public:
		/// Creates an empty object.
		_scoped_assignment() = default;
		/// Assigns the value to the target.
		_scoped_assignment(T &target, T value) : _old_value(std::move(target)), _target(&target) {
			target = std::move(value);
		}
		/// No copy construction.
		_scoped_assignment(const _scoped_assignment&) = delete;
		/// Move constructor.
		_scoped_assignment(_scoped_assignment &&src) : _old_value(std::move(src._old_value)), _target(src._target) {
			src._target = nullptr;
		}
		/// No copy assignment.
		_scoped_assignment &operator=(const _scoped_assignment&) = delete;
		/// Move assignment.
		_scoped_assignment &operator=(_scoped_assignment &&src) noexcept {
			reset();
			_old_value = std::move(src._old_value);
			_target = src._target;
			src._target = nullptr;
			return *this;
		}
		/// Destructor, calls \ref reset().
		~_scoped_assignment() {
			reset();
		}

		/// Manually resets this struct and the target value.
		void reset() {
			if (_target) {
				*_target = std::move(_old_value);
			}
		}
	private:
		T _old_value{}; ///< The old value.
		T *_target = nullptr; ///< The target.
	};
	/// Shorthand for creating \ref _scoped_assignment objects.
	template <typename T> [[nodiscard]] _scoped_assignment<T> _scoped_assign_to(T &target, T value) {
		return _scoped_assignment<T>(target, std::move(value));
	}

	/// Returns multiple importance sampling weight of the given path. The \p no_light parameter indicates whether
	/// the entire light path is ignored because the camera path is used for lighting estimation.
	double _mis_weight(
		_path_vec &cam_path, _path_vec &light_path,
		std::size_t cam_id, std::size_t light_id, std::size_t num_lights, bool no_light
	) {
		_vertex
			&cam_vert = cam_path[cam_id],
			&prev_cam_vert = cam_path[cam_id - 1],
			&light_vert = light_path[light_id],
			*prev_light_vert = light_id > 0 ? &light_path[light_id - 1] : nullptr;
		double prev_cam_pdf, cam_pdf;
		if (no_light) {
			prev_cam_pdf = cam_vert.pdf_light_to(prev_cam_vert);
			cam_pdf = 1.0 / (static_cast<double>(num_lights) * cam_vert.prim->surface_area());
		} else {
			prev_cam_pdf = cam_vert.pdf_from_to(light_vert, prev_cam_vert);
			if (light_id == 0) {
				cam_pdf = light_vert.pdf_light_to(cam_vert);
			} else {
				cam_pdf = light_vert.pdf_from_to(*prev_light_vert, cam_vert);
			}
		}
		auto
			sa_prev_cam_vert_pdf_rev = _scoped_assign_to(prev_cam_vert.pdf_reverse, prev_cam_pdf),
			sa_cam_vert_pdf_rev = _scoped_assign_to(cam_vert.pdf_reverse, cam_pdf),
			sa_light_vert_pdf_rev = _scoped_assign_to(
				light_vert.pdf_reverse, cam_vert.pdf_from_to(prev_cam_vert, light_vert)
			);
		_scoped_assignment<double> sa_prev_light_vert_pdf_rev;
		if (prev_light_vert) {
			sa_prev_light_vert_pdf_rev = _scoped_assign_to(
				prev_light_vert->pdf_reverse, light_vert.pdf_from_to(cam_vert, *prev_light_vert)
			);
		}
		double sum_ri = 0.0;
		{ // camera subpath
			double ri = 1.0;
			bool prev_delta = light_vert.is_delta; // whether the previous vertex is delta
			for (std::size_t i = cam_id + 1; i > 2; ) {
				--i;
				const _vertex &cur_vert = cam_path[i];
				bool next_delta = cam_path[i - 1].is_delta;
				ri *=
					(prev_delta ? 1.0 : cur_vert.pdf_reverse) /
					(next_delta ? 1.0 : cur_vert.pdf_forward);
				if (!cur_vert.is_delta && !next_delta) {
					sum_ri += ri;
				}
				prev_delta = cur_vert.is_delta;
			}
		}
		if (!no_light) { // light subpath
			double ri = 1.0;
			bool prev_delta = cam_vert.is_delta;
			for (std::size_t i = light_id + 1; i > 0; ) {
				--i;
				const _vertex &cur_vert = light_path[i];
				bool next_delta = i > 1 ? light_path[i - 1].is_delta : false;
				ri *=
					(prev_delta ? 1.0 : cur_vert.pdf_reverse) /
					(next_delta ? 1.0 : cur_vert.pdf_forward);
				if (!cur_vert.is_delta && !next_delta) {
					sum_ri += ri;
				}
				prev_delta = cur_vert.is_delta;
			}
		}
		return 1.0 / (1.0 + sum_ri);
	}

	/// Returns the generalized geometry term.
	double _geometry(vec3d diff, vec3d n1, vec3d n2) {
		double sqr_length = diff.squared_length();
		return std::abs(vec_ops::dot(diff, n1) * vec_ops::dot(diff, n2)) / (sqr_length * sqr_length);
	}
	/// \overload
	double _geometry(vec3d p1, vec3d p2, vec3d n1, vec3d n2) {
		return _geometry(p2 - p1, n1, n2);
	}

	spectrum bidirectional_path_tracer::incoming_light(const scene &sc, const ray &r, pcg32 &random) const {
		std::size_t num_lights = sc.get_lights().size();
		if (num_lights == 0) {
			return spectrum();
		}
		std::uniform_real_distribution<double> dist(0.0, 1.0);
		std::uniform_int_distribution<std::size_t> light_dist(0, num_lights - 1);

		// normalize camera ray direction
		ray cam_ray = r;
		cam_ray.direction = cam_ray.direction.normalized_unchecked();
		// sample light ray
		const primitive *light = sc.get_lights()[light_dist(random)];
		primitives::surface_sample surf_sample = light->sample_surface(vec2d(dist(random), dist(random)));
		// only purely diffuse light sources are supported
		vec3d light_ray_dir_tangent = warping::unit_hemisphere_from_unit_square_cosine(
			vec2d(dist(random), dist(random))
		);
		double light_ray_dir_pdf = warping::pdf_unit_hemisphere_from_unit_square_cosine(light_ray_dir_tangent);
		ray light_ray = scene::spawn_ray_from(
			surf_sample.position, light_ray_dir_tangent, surf_sample.geometric_normal, ray_offset
		);

		// trace camera path
		_path_vec cam_path;
		{
			_vertex &cam_vert = cam_path.emplace_back();
			cam_vert.attenuation = spectrum::identity;
			cam_vert.position = r.origin;
		}
		// TODO camera pdf?
		_trace_path(cam_path, sc, max_camera_bounces, cam_ray, 1.0, transport_mode::radiance, ray_offset, random);
		// trace light path
		_path_vec light_path;
		{
			_vertex &light_vert = light_path.emplace_back();
			light_vert.attenuation =
				light->entity->mat.emission.get_value(surf_sample.uv) *
				vec_ops::dot(surf_sample.geometric_normal, light_ray.direction) *
				static_cast<double>(num_lights) /
				(light_ray_dir_pdf * surf_sample.pdf);
			light_vert.tangent = compute_arbitrary_tangent_space(surf_sample.geometric_normal);
			light_vert.position = surf_sample.position;
			light_vert.geometric_normal = surf_sample.geometric_normal;
			light_vert.uv = surf_sample.uv;
			light_vert.pdf_forward = surf_sample.pdf / static_cast<double>(num_lights);
			light_vert.prim = light;
		}
		_trace_path(
			light_path, sc, max_light_bounces, light_ray, light_ray_dir_pdf, transport_mode::importance,
			ray_offset, random
		);

		spectrum result;
		// connect light rays
		for (std::size_t ci = 1; ci < cam_path.size(); ++ci) {
			_vertex &cam_vert = cam_path[ci];
			// account for direct light hits
			if (!cam_vert.prim->entity->mat.emission.modulation.near_zero()) {
				spectrum s = modulate(
					cam_vert.attenuation, cam_vert.prim->entity->mat.emission.get_value(cam_vert.uv)
				);
				s *= _mis_weight(cam_path, light_path, ci, 0, num_lights, true);
				result += s;
			}
			if (!cam_vert.is_delta) {
				{ // sample a point on a light
					const primitive *new_light = sc.get_lights()[light_dist(random)];
					primitives::surface_sample new_surf_sample = new_light->sample_surface(
						vec2d(dist(random), dist(random))
					);
					if (sc.test_visibility(new_surf_sample.position, cam_vert.position, ray_offset)) {
						_vertex light_vert;
						light_vert.position = new_surf_sample.position;
						light_vert.geometric_normal = new_surf_sample.geometric_normal;
						light_vert.uv = new_surf_sample.uv;
						light_vert.attenuation =
							new_light->entity->mat.emission.get_value(new_surf_sample.uv) *
							(static_cast<double>(num_lights) / new_surf_sample.pdf);
						light_vert.pdf_forward = new_surf_sample.pdf / static_cast<double>(num_lights);
						light_vert.prim = new_light;
						spectrum s = modulate(cam_vert.attenuation, light_vert.attenuation);
						vec3d diff = light_vert.position - cam_vert.position;
						s = modulate(s, cam_vert.surface_bsdf.f(
							cam_vert.tangent * diff.normalized_unchecked(),
							cam_vert.incoming_ray_dir_tangent,
							transport_mode::radiance
						));
						s *= _geometry(diff, cam_vert.geometric_normal, new_surf_sample.geometric_normal);
						auto sa_light_vert = _scoped_assign_to(light_path[0], light_vert);
						s *= _mis_weight(cam_path, light_path, ci, 0, num_lights, false);
						result += s;
					}
				}
				// other generic connection scenarios
				for (std::size_t li = 1; li < light_path.size(); ++li) {
					_vertex &light_vert = light_path[li];
					if (!light_vert.is_delta) {
						spectrum s = modulate(cam_vert.attenuation, light_vert.attenuation);
						vec3d cam_to_light_norm = (light_vert.position - cam_vert.position).normalized_unchecked();
						s = modulate(s, cam_vert.surface_bsdf.f(
							cam_vert.tangent * cam_to_light_norm, cam_vert.incoming_ray_dir_tangent,
							transport_mode::radiance
						));
						s = modulate(s, light_vert.surface_bsdf.f(
							light_vert.tangent * -cam_to_light_norm, light_vert.incoming_ray_dir_tangent,
							transport_mode::importance
						));
						if (!s.near_zero()) {
							if (sc.test_visibility(cam_vert.position, light_vert.position, ray_offset)) {
								// multiply by G term
								s *= _geometry(
									cam_vert.position, light_vert.position,
									cam_vert.geometric_normal, light_vert.geometric_normal
								);
								s *= _mis_weight(cam_path, light_path, ci, li, num_lights, false);
								result += s;
							}
						}
					}
				}
			}
		}
		return result;
	}
}
